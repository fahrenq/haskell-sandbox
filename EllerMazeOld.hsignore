module ElMazeOld where

import           Data.List
import           System.Random
import           Debug.Trace

{-
Example ASCII
 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __
|__   |__       __ __|__   |   __|  |  |  |  |
|__   |__   |__|   __ __|   __ __      |     |
|        |  |  |     |  |__      |__|  |  |  |
|__|__|  |  |   __|   __|__   |   __|__|  |__|
|   __|  |     |__ __ __|  |  |__|  |     |  |
|  |  |  |  |__|  |__   |  |   __|__ __|  |  |
|  |__    __    __ __    __|  |   __   |  |  |
|  |  |  |  |      __|  |   __|  |  |__|  |  |
|  |     |     |__   |  |  |  |  |  |__    __|
|  |  |__|__|__ __|  |     |  |  |      __|  |
|__ __|  |  |  |__   |__|   __|     |   __ __|
|   __|  |   __|__      |__   |__|  |__    __|
|  |  |     |  |     |__|  |   __    __|   __|
|   __|  |__ __|__|      __|  |  |     |  |  |
|   __ __   |      __|__|  |__   |  |  |__|  |
|__ __ __|__ __|__ __ __ __ __|__|__|__ __ __|
-}

type Cell = (Bool, Bool) -- Right, Bottom
type Row = [Cell]
type Maze = [Row]

cellToStr :: Cell -> String
cellToStr (True , True ) = "__|"
cellToStr (False, True ) = "__ "
cellToStr (True , False) = "  |"
cellToStr (False, False) = "   "

cell'ToStr :: Cell' -> String
cell'ToStr (x, (True, True)  ) = show x ++ "_|" -- __|
cell'ToStr (x, (False, True) ) = show x ++ "_ " -- "__ "
cell'ToStr (x, (True, False) ) = show x ++ " |" -- "  |"
cell'ToStr (x, (False, False)) = show x ++ "  " -- " .  "

sampleMaze :: Maze
sampleMaze =
  [ [(False, True), (False, False), (True, False)]
  , [(True, False), (True, True), (True, False)]
  , [(False, True), (True, True), (True, True)]
  ]

showRow :: Row -> String
showRow row = "|" ++ concatMap cellToStr row

showRow' :: Row' -> String
showRow' row = "|" ++ concatMap cell'ToStr row

showMazeTopLine :: Int -> String
showMazeTopLine mazeWidth = concat (replicate mazeWidth " __")

-- Maze's bottom side cells should always have bottom wall
-- Maze's right side cells should always have right wall
validateMaze :: Maze -> Bool
-- validateMaze maze = all snd (last maze) && all (fst . last) maze
validateMaze maze = True

showMaze :: Maze -> String
showMaze m = if validateMaze m
  then showMazeTopLine mazeWidth ++ "\n" ++ intercalate "\n" (map showRow m)
  else "Invalid maze"
  where mazeWidth = length $ head m

showMaze' :: [Row'] -> String
showMaze' m = showMazeTopLine mazeWidth ++ "\n" ++ intercalate
  "\n"
  (map showRow' m)
  where mazeWidth = length $ head m

type Cell' = (Int, Cell)
type Row' = [Cell']

emptyRow :: Int -> Row'
emptyRow width = zip [0 ..] $ replicate width (False, True) -- setting floor to true here is kinda dirty

-- Overall: right wall is always false, as we're setting the wall between passed cells only.

handleRowFunctor :: Int -> (StdGen, [Cell']) -> Cell' -> (StdGen, [Cell'])
handleRowFunctor mazeWidth (gen, acc) upRowCell'
  | isFirstCell -- Handle logic for set and floor based on the upRowCell'
  -- = trace debugString (outputGen, [(set, (False, floor))])
  = (outputGen, [(set, (False, floor))])
  | (lastSet == set) || rngFloorValue -- we add a wall and add floor if not exists already to a previous set
  = let lastSetCells     = filter (\x -> fst x == lastSet) acc
        lastCellNewFloor = not (all (snd . snd) lastSetCells) && snd lastCell
    in
      -- trace
      --     (  debugString
      --     ++ "\nLast Set Cells: "
      --     ++ show lastSetCells
      --     ++ "\nLastCellNewFloor: "
      --     ++ show lastCellNewFloor
      --     )
        ( outputGen
        , init acc
          ++ [(lastSet, (True, lastCellNewFloor)), (set, (False, floor))]
        )
  | otherwise
  -- = trace debugString (outputGen, acc ++ [(lastSet, (False, floor))])
  = (outputGen, acc ++ [(lastSet, (False, floor))])
 where
  isFirstCell           = null acc
  isLastCell            = length acc == mazeWidth - 1

  (upRowSet, upRowCell) = upRowCell'
  upRowFloor            = snd upRowCell
  newSet                = upRowFloor

  lastCell'             = last acc
  (lastSet, lastCell)   = lastCell'

  -- if upRow has floor - new unique set, otherwise set same as upRow
  -- use this set unless we union sets when adding a wall
  set                   = if newSet then upRowSet + 1000 else upRowSet
  floor                 = rngFloorValue

  rngLeftWall           = randomR (True, False) gen
  rngLeftWallGen        = snd rngLeftWall
  rngLeftWallValue      = fst rngLeftWall

  rngFloor              = randomR (True, False) rngLeftWallGen
  rngFloorGen           = snd rngFloor
  rngFloorValue         = fst rngFloor

  outputGen             = rngFloorGen

  debugString =
    let cellMethod | isFirstCell                       = "1"
                   | lastSet == set                    = "2 (same set)"
                   | (lastSet == set) || rngFloorValue = "2 (rng)"
                   | otherwise                         = "3"

        lastSet' | isFirstCell = "NONE"
                 | otherwise   = show lastSet
    in  "\n\nCell Method: "
          ++ cellMethod
          ++ "\nLast Set: "
          ++ lastSet'
          ++ "\nSet:"
          ++ show set
          ++ "\nFloor:"
          ++ show floor


handleRow :: Int -> StdGen -> Row' -> (StdGen, Row')
handleRow mazeWidth gen = foldl (handleRowFunctor mazeWidth) (gen, [])

generateMaze :: Int -> Int -> StdGen -> [Row']
generateMaze width height gen = snd -- throw away generator
                                    $ foldl
  (\(lgen, rows) _ ->
    let (ngen, row) = handleRow
          width
          lgen
          (if null rows then emptyRow width else last rows)
    in  (ngen, rows ++ [row])
  )
  (gen, [])
  [0 .. height]

main :: IO ()
main = do
  -- gen <- getStdGen
  putStrLn $ showMaze' (generateMaze 20 20 gen)
  putStrLn $ showMaze (map (map snd) $ generateMaze 20 20 gen)
  where gen = mkStdGen 10

-- handleRowFunctor :: (StdGen, [Cell']) -> Cell' -> (StdGen, [Cell'])
-- handleWallsFunctor (gen, acc) upRowCell' =


handleWalls :: StdGen -> Row' -> (StdGen, Row')
handleWalls gen row = foldl handleWallsFunctor (gen, [])
